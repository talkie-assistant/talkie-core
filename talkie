#!/usr/bin/env bash
# Talkie service management CLI
# Usage: ./talkie <command> [options]

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "$SCRIPT_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    echo -e "${BLUE}[DEBUG]${NC} $1"
}

# Check if podman is installed
check_podman() {
    if ! command -v podman &> /dev/null; then
        log_error "Podman is not installed."
        echo "Install Podman:"
        echo "  macOS: brew install podman"
        echo "  Linux: See https://podman.io/getting-started/installation"
        exit 1
    fi
}

# Check if podman-compose is available
check_podman_compose() {
    if command -v podman-compose &> /dev/null; then
        COMPOSE_CMD="podman-compose"
    elif podman compose version &> /dev/null 2>&1; then
        COMPOSE_CMD="podman compose"
    else
        log_error "podman-compose not found. Install it:"
        echo "  pip install podman-compose"
        echo "  or use podman compose (requires podman 4.0+)"
        exit 1
    fi
}

# Initialize compose command
init_compose() {
    check_podman
    check_podman_compose
}

# Ensure talkie network exists (matches compose.yaml: subnet 172.30.0.0/24, labels for Docker Compose)
ensure_talkie_network() {
    if ! podman network exists talkie_talkie-network 2>/dev/null; then
        log_info "Creating talkie network (talkie_talkie-network)..."
        podman network create \
            --driver bridge \
            --subnet 172.30.0.0/24 \
            --label com.docker.compose.project=talkie \
            --label com.docker.compose.network=talkie-network \
            --label io.podman.compose.project=talkie \
            talkie_talkie-network
    fi
}

# Single compose service names (for: ./talkie start haproxy, etc.). Ollama disabled (use local ollama serve).
COMPOSE_SERVICES="consul-server keydb haproxy chroma speech rag browser healthbeat"

# Start services
cmd_start() {
    local services="${1:-all}"
    local svc

    if [ "$services" = "web" ]; then
        cmd_web_start
        return
    fi
    for svc in $COMPOSE_SERVICES; do
        if [ "$services" = "$svc" ]; then
            init_compose
            log_info "Starting $services..."
            if ! $COMPOSE_CMD up -d "$services"; then
                log_info "Starting existing container talkie-$services..."
                podman start "talkie-$services" || { log_error "Failed to start talkie-$services"; return 1; }
            fi
            return
        fi
    done

    init_compose
    log_info "Starting Talkie services..."

    if [ "$services" = "all" ]; then
        ensure_talkie_network
        if ! $COMPOSE_CMD up -d consul-server keydb haproxy chroma speech rag browser healthbeat; then
            log_info "Recreating network and retrying..."
            for c in talkie-consul-server talkie-keydb talkie-haproxy talkie-chroma talkie-speech talkie-rag talkie-browser talkie-healthbeat; do
                podman stop "$c" 2>/dev/null || true
            done
            podman network rm talkie_talkie-network 2>/dev/null || true
            sleep 1
            $COMPOSE_CMD up -d consul-server keydb haproxy chroma speech rag browser healthbeat
        fi
        log_info "Starting Web UI (background)..."
        cmd_web_start
        log_info "All services started"
        cmd_status
    elif [ "$services" = "core" ]; then
        log_info "Starting core services (Chroma; Ollama is local)..."
        $COMPOSE_CMD up -d chroma
    elif [ "$services" = "modules" ]; then
        log_info "Starting module servers..."
        $COMPOSE_CMD up -d speech rag browser healthbeat
    fi

    if [ "$services" = "all" ]; then
        :
    elif [ "$services" = "core" ] || [ "$services" = "modules" ]; then
        log_info "Services started"
    else
        log_warn "Unknown target: $services. Use: all, core, modules, or a service name (e.g. consul-server, keydb, haproxy)."
    fi
}

# Stop services
cmd_stop() {
    local services="${1:-all}"
    local svc

    if [ "$services" = "web" ]; then
        cmd_web_stop
        return
    fi
    for svc in $COMPOSE_SERVICES; do
        if [ "$services" = "$svc" ]; then
            init_compose
            log_info "Stopping $services..."
            $COMPOSE_CMD stop "$services" 2>/dev/null || true
            log_info "Services stopped"
            return
        fi
    done

    init_compose
    log_info "Stopping Talkie services..."

    if [ "$services" = "all" ]; then
        cmd_web_stop
    fi

    if [ "$services" = "all" ] || [ "$services" = "modules" ]; then
        log_info "Stopping module servers..."
        $COMPOSE_CMD stop speech rag browser healthbeat 2>/dev/null || true
    fi

    if [ "$services" = "all" ] || [ "$services" = "core" ]; then
        log_info "Stopping core services..."
        $COMPOSE_CMD stop chroma 2>/dev/null || true
    fi

    if [ "$services" = "all" ]; then
        log_info "Stopping infrastructure services..."
        for svc in consul-server keydb haproxy; do
            $COMPOSE_CMD stop "$svc" 2>/dev/null || true
        done
    fi

    log_info "Services stopped"
}

# Restart services (use compose restart for containers to avoid "name already in use")
cmd_restart() {
    local services="${1:-all}"
    local svc

    log_info "Restarting services: $services"

    if [ "$services" = "web" ]; then
        cmd_web_restart
        return
    fi
    for svc in $COMPOSE_SERVICES; do
        if [ "$services" = "$svc" ]; then
            init_compose
            log_info "Restarting $services..."
            if ! $COMPOSE_CMD restart "$services" 2>/dev/null; then
                log_info "Restarting existing container talkie-$services..."
                podman stop "talkie-$services" 2>/dev/null || true
                podman start "talkie-$services" || { log_error "Failed to restart talkie-$services"; return 1; }
            fi
            return
        fi
    done

    if [ "$services" = "all" ]; then
        init_compose
        log_info "Stopping all services..."
        cmd_stop "all"
        sleep 2
        log_info "Starting all services..."
        cmd_start "all"
        return
    fi

    # core | modules (or unknown target)
    init_compose
    cmd_stop "$services"
    sleep 1
    cmd_start "$services"
}

# Web server PID file (logs go to talkie.log via app config)
WEB_PID_FILE="$SCRIPT_DIR/.talkie-web.pid"

cmd_web_start() {
    if [ -f "$WEB_PID_FILE" ]; then
        local pid
        pid=$(cat "$WEB_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log_info "Web UI already running (PID $pid). http://localhost:8765"
            return 0
        fi
        rm -f "$WEB_PID_FILE"
    fi
    # If port 8765 is in use (e.g. stale process), free it before starting
    if command -v lsof &>/dev/null; then
        local port_pid
        port_pid=$(lsof -ti :8765 2>/dev/null | head -1)
        if [ -n "$port_pid" ]; then
            log_info "Killing process $port_pid holding port 8765"
            kill "$port_pid" 2>/dev/null || true
            sleep 2
        fi
    fi
    log_info "Starting Talkie Web UI..."
    ( cd "$SCRIPT_DIR" && nohup pipenv run python run_web.py >> talkie.log 2>&1 & echo $! > "$WEB_PID_FILE" )
    sleep 1
    if [ -f "$WEB_PID_FILE" ] && kill -0 "$(cat "$WEB_PID_FILE")" 2>/dev/null; then
        log_info "Web UI started (PID $(cat "$WEB_PID_FILE")). http://localhost:8765"
    else
        log_error "Web UI failed to start. Check talkie.log"
        rm -f "$WEB_PID_FILE"
        exit 1
    fi
}

cmd_web_stop() {
    if [ -f "$WEB_PID_FILE" ]; then
        local pid
        pid=$(cat "$WEB_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            sleep 1
            kill -9 "$pid" 2>/dev/null || true
        fi
        rm -f "$WEB_PID_FILE"
        log_info "Web UI stopped"
    else
        log_info "Web UI not running"
    fi
}

cmd_web_restart() {
    cmd_web_stop
    sleep 1
    cmd_web_start
}

# Check if port 8765 is listening (macOS and Linux)
web_port_listening() {
    if command -v lsof &>/dev/null; then
        lsof -i :8765 2>/dev/null | grep -q LISTEN
    else
        [ -n "$(ss -tln 2>/dev/null | grep ':8765 ')" ] || [ -n "$(netstat -tln 2>/dev/null | grep ':8765 ')" ]
    fi
}

cmd_web_status() {
    if [ -f "$WEB_PID_FILE" ]; then
        local pid
        pid=$(cat "$WEB_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            if web_port_listening; then
                echo -e "Web UI: ${GREEN}running${NC} (PID $pid, port 8765). http://localhost:8765"
            else
                echo -e "Web UI: process running (PID $pid) but ${YELLOW}port 8765 not listening${NC}. Check talkie.log"
            fi
        else
            echo -e "Web UI: ${RED}stopped${NC} (stale PID file removed)"
            rm -f "$WEB_PID_FILE"
        fi
    else
        if web_port_listening; then
            echo -e "Web UI: port 8765 in use by another process (not managed by talkie)"
        else
            echo -e "Web UI: ${RED}stopped${NC}. Run: ./talkie start web"
        fi
    fi
}

# --- App command (replaces start.sh): bring up services then run UI ---
is_container_running() {
    local container_name=$1
    podman ps --format "{{.Names}}" | grep -q "^${container_name}$"
}

app_check_container_health() {
    local container_name=$1
    local max_attempts=${2:-10}
    local attempt=0
    while [ $attempt -lt $max_attempts ]; do
        local health
        health=$(podman inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "none")
        if [ "$health" = "healthy" ]; then return 0; fi
        if [ "$health" = "unhealthy" ]; then return 1; fi
        if [ "$health" = "none" ] || [ "$health" = "" ]; then
            is_container_running "$container_name" && return 0 || return 1
        fi
        attempt=$((attempt + 1))
        sleep 1
    done
    return 1
}

app_health_check_service() {
    local service_name=$1
    local container_name=$2
    local check_url=$3
    if ! is_container_running "$container_name"; then
        log_warn "$service_name container ($container_name) is not running"
        return 1
    fi
    if [ -n "$check_url" ]; then
        if curl -s -f "$check_url" > /dev/null 2>&1; then
            log_info "$service_name is healthy"
            return 0
        else
            log_warn "$service_name is running but health check failed at $check_url"
            return 1
        fi
    fi
    if app_check_container_health "$container_name" 3; then
        log_info "$service_name is healthy"
        return 0
    else
        log_warn "$service_name container exists but health check failed"
        return 1
    fi
}

app_check_python() {
    if ! command -v python3 &> /dev/null; then
        log_error "Python 3 is not installed."
        echo "Install Python 3.11+: macOS: brew install python@3.11"
        exit 1
    fi
    log_info "Python found: $(python3 --version 2>&1)"
    if ! command -v pipenv &> /dev/null; then
        log_warn "pipenv not found. Installing..."
        pip3 install --user pipenv || { log_error "Failed to install pipenv."; exit 1; }
        export PATH="$HOME/.local/bin:$PATH"
    fi
    log_info "pipenv found: $(pipenv --version)"
}

app_install_deps() {
    local need_install=false
    if [ ! -f "Pipfile.lock" ] || [ "Pipfile" -nt "Pipfile.lock" ]; then need_install=true; fi
    if [ "$need_install" = true ]; then
        log_info "Installing/updating Python dependencies..."
        pipenv install --dev || { log_error "Failed to install dependencies."; exit 1; }
    else
        if ! pipenv --venv &> /dev/null; then
            pipenv install --dev || { log_error "Failed to install dependencies."; exit 1; }
        fi
    fi
}

app_setup_data_dir() {
    [ ! -d "data" ] && mkdir -p data
    if [ ! -f "config.yaml" ]; then
        log_error "config.yaml not found."
        exit 1
    fi
}

# Register chroma (and optionally ollama) with Consul so *.service.consul resolves. Ollama disabled (local).
app_register_consul_services() {
    if ! is_container_running "talkie-consul-server"; then
        return
    fi
    local consul_addr="http://localhost:8500"
    if ! curl -s -f "${consul_addr}/v1/status/leader" > /dev/null 2>&1; then
        log_debug "Consul not reachable; skipping service registration"
        return
    fi
    for name in chroma; do
        local cid port
        case "$name" in
            chroma) cid="talkie-chroma"; port=8000 ;;
            *) continue ;;
        esac
        if ! is_container_running "$cid"; then
            continue
        fi
        local ip
        ip=$(podman inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$cid" 2>/dev/null | head -1)
        if [ -z "$ip" ]; then
            ip=$(podman inspect --format '{{.NetworkSettings.IPAddress}}' "$cid" 2>/dev/null)
        fi
        if [ -z "$ip" ]; then
            log_debug "Could not get IP for $cid; skipping Consul registration"
            continue
        fi
        local payload
        payload=$(printf '{"ID":"%s-1","Name":"%s","Address":"%s","Port":%s}' "$name" "$name" "$ip" "$port")
        if curl -s -X PUT -d "$payload" "${consul_addr}/v1/agent/service/register" > /dev/null 2>&1; then
            log_debug "Registered $name with Consul at $ip:$port"
        else
            log_debug "Consul registration failed for $name"
        fi
    done
}

# Check local Ollama (no Podman container). Ensure model is available and warm up.
app_check_ollama_models() {
    log_info "Checking local Ollama..."
    if ! curl -s http://localhost:11434/api/tags > /dev/null 2>&1; then
        log_info "Waiting for Ollama (run: ollama serve)..."
        sleep 10
        if ! curl -s http://localhost:11434/api/tags > /dev/null 2>&1; then
            log_error "Ollama not responding at http://localhost:11434. Run: ollama serve"
            exit 1
        fi
    fi
    local DEFAULT_MODEL=phi
    [ -f config.yaml ] && DEFAULT_MODEL=$(grep -E "^\s*model_name:" config.yaml | head -1 | sed 's/.*model_name:\s*\([^ ]*\).*/\1/' | tr -d '"' || echo "phi")
    local MODELS_JSON MODELS MODEL_FOR_API
    MODELS_JSON=$(curl -s http://localhost:11434/api/tags 2>/dev/null || echo "{}")
    MODELS=$(echo "$MODELS_JSON" | grep -o '"name":"[^"]*"' | cut -d'"' -f4 || echo "")
    if ! echo "$MODELS" | grep -qE "^${DEFAULT_MODEL}(:|$)"; then
        log_info "Pulling model '$DEFAULT_MODEL' (local ollama)..."
        ollama pull "$DEFAULT_MODEL" || { log_warn "ollama pull failed; ensure ollama is on PATH"; }
        MODELS_JSON=$(curl -s http://localhost:11434/api/tags 2>/dev/null || echo "{}")
        MODELS=$(echo "$MODELS_JSON" | grep -o '"name":"[^"]*"' | cut -d'"' -f4 || echo "")
    fi
    log_info "Warming up Ollama model '$DEFAULT_MODEL'..."
    MODEL_FOR_API=$(echo "$MODELS" | grep -E "^${DEFAULT_MODEL}(:|$)" | head -1)
    [ -z "$MODEL_FOR_API" ] && MODEL_FOR_API="$DEFAULT_MODEL"
    if ! curl -s -X POST http://localhost:11434/api/generate -H "Content-Type: application/json" \
        -d "{\"model\":\"$MODEL_FOR_API\",\"prompt\":\"ok\",\"stream\":false}" --max-time 90 > /dev/null 2>&1; then
        log_warn "Ollama warmup failed (first request may 500)."
    fi
    if [ -f config.yaml ] && grep -q "embedding_model:" config.yaml; then
        local EMBED_MODEL
        EMBED_MODEL=$(grep -E "^\s*embedding_model:" config.yaml | head -1 | sed 's/.*embedding_model:\s*\([^ ]*\).*/\1/' | tr -d '"' || echo "")
        if [ -n "$EMBED_MODEL" ] && ! echo "$MODELS" | grep -qE "^${EMBED_MODEL}(:|$)"; then
            log_info "Pulling embedding model '$EMBED_MODEL' (local ollama)..."
            ollama pull "$EMBED_MODEL" || true
        fi
    fi
}

cmd_app() {
    local LOCAL_ONLY=0
    while [ $# -gt 0 ]; do
        case "$1" in
            --local-only) LOCAL_ONLY=1; shift ;;
            *) break ;;
        esac
    done
    init_compose
    log_info "Starting Talkie (services in containers, Web UI runs locally)..."
    [ "$LOCAL_ONLY" -eq 1 ] && log_info "Local-only: module servers will not be started"
    echo ""
    app_check_python
    app_setup_data_dir
    app_install_deps
    log_info "Prebuilding container images..."
    $COMPOSE_CMD build
    log_info "Ensuring infrastructure services are running..."
    local INFRA_SERVICES=(consul-server keydb haproxy)
    local NEED_INFRA=false
    for sn in "${INFRA_SERVICES[@]}"; do
        if ! is_container_running "talkie-$sn"; then NEED_INFRA=true; break; fi
    done
    if [ "$NEED_INFRA" = true ]; then
        ensure_talkie_network
        $COMPOSE_CMD up -d "${INFRA_SERVICES[@]}"
        log_info "Waiting for infrastructure (20s)..."
        sleep 20
    fi
    app_health_check_service "Consul" "talkie-consul-server" "http://localhost:8500/v1/status/leader" || log_warn "Consul health check failed"
    is_container_running "talkie-keydb" && podman exec talkie-keydb keydb-cli ping > /dev/null 2>&1 && log_info "KeyDB is ready" || log_warn "KeyDB failed"
    app_health_check_service "HAProxy" "talkie-haproxy" "http://localhost:8404/" || log_warn "HAProxy health check failed"
    log_info "Ensuring application services (Chroma; Ollama is local)..."
    local APP_SERVICES=(chroma)
    local NEED_APP=false
    for sn in "${APP_SERVICES[@]}"; do
        if ! is_container_running "talkie-$sn"; then NEED_APP=true; break; fi
    done
    if [ "$NEED_APP" = true ]; then
        $COMPOSE_CMD up -d "${APP_SERVICES[@]}"
        log_info "Waiting for application services (20s)..."
        sleep 20
    fi
    if curl -s -f http://localhost:11434/api/tags > /dev/null 2>&1; then
        log_info "Ollama (local) is healthy"
    else
        log_warn "Ollama not responding at localhost:11434. Run: ollama serve"
    fi
    app_health_check_service "Chroma" "talkie-chroma" "http://localhost:8000/api/v1" || log_warn "Chroma may still be starting"
    app_register_consul_services
    if [ "$LOCAL_ONLY" -eq 0 ]; then
        log_info "Checking module servers..."
        local MODULE_SERVICES=("speech:talkie-speech:http://localhost:8001/health" "rag:talkie-rag:http://localhost:8002/health" "browser:talkie-browser:http://localhost:8003/health")
        local TO_START=() TO_RESTART=()
        for info in "${MODULE_SERVICES[@]}"; do
            IFS=':' read -r sn cn url <<< "$info"
            if is_container_running "$cn"; then
                local hs
                hs=$(podman inspect --format='{{.State.Health.Status}}' "$cn" 2>/dev/null || echo "none")
                if [ "$hs" = "unhealthy" ]; then TO_RESTART+=("$sn"); elif [ -n "$url" ] && ! curl -s -f "$url" > /dev/null 2>&1; then TO_RESTART+=("$sn"); else log_info "$sn is running and healthy"; fi
            else
                TO_START+=("$sn")
            fi
        done
        [ ${#TO_RESTART[@]} -gt 0 ] && $COMPOSE_CMD restart "${TO_RESTART[@]}" && sleep 2
        [ ${#TO_START[@]} -gt 0 ] && $COMPOSE_CMD up -d "${TO_START[@]}" && log_info "Module servers starting..." && sleep 3
        log_info "Consul UI: http://localhost:8500/ui"
    fi
    app_check_ollama_models
    log_info "Starting Talkie Web UI. http://localhost:8765"
    exec pipenv run python run_web.py
}

# View logs
cmd_logs() {
    local service="${1:-}"
    local follow="${2:-}"
    init_compose
    
    if [ -z "$service" ]; then
        log_info "Available services:"
        echo "  Infrastructure: consul-server, keydb, haproxy"
        echo "  Core: chroma (Ollama is local)"
        echo "  Modules: speech, rag, browser, healthbeat"
        echo ""
        echo "Usage: ./talkie logs <service> [--follow]"
        echo "Example: ./talkie logs consul-server --follow"
        return
    fi
    
    if [ "$follow" = "--follow" ] || [ "$follow" = "-f" ]; then
        podman logs -f "talkie-$service" 2>/dev/null || log_error "Service 'talkie-$service' not found or not running"
    else
        podman logs "talkie-$service" 2>/dev/null || log_error "Service 'talkie-$service' not found or not running"
    fi
}

# Status and health (combined)
cmd_status() {
    init_compose
    
    log_info "Talkie service status and health:"
    echo ""
    
    # Capture consul state once (container running + API reachable). Use 127.0.0.1 for curl to avoid IPv6/localhost quirks on macOS.
    _consul_running=0
    _consul_healthy=0
    if podman ps --format "{{.Names}}" 2>/dev/null | grep -q "^talkie-consul-server$"; then
        _consul_running=1
        for _ in 1 2 3; do
            if curl -s -m 3 http://127.0.0.1:8500/v1/status/leader > /dev/null 2>&1; then
                _consul_healthy=1
                break
            fi
            sleep 1
        done
    fi

    # Infrastructure (running + health)
    echo "Infrastructure:"
    if [ "$_consul_running" -eq 1 ]; then
        if [ "$_consul_healthy" -eq 1 ]; then
            echo -e "  ${GREEN}✓${NC} consul-server (running, healthy)"
        else
            echo -e "  ${YELLOW}!${NC} consul-server (running, not responding)"
        fi
    else
        echo -e "  ${RED}✗${NC} consul-server (stopped)"
    fi
    if podman ps --format "{{.Names}}" | grep -q "^talkie-keydb$"; then
        if podman exec talkie-keydb keydb-cli ping > /dev/null 2>&1; then
            echo -e "  ${GREEN}✓${NC} keydb (running, healthy)"
        else
            echo -e "  ${YELLOW}!${NC} keydb (running, not responding)"
        fi
    else
        echo -e "  ${RED}✗${NC} keydb (stopped)"
    fi
    if podman ps --format "{{.Names}}" | grep -q "^talkie-haproxy$"; then
        if curl -s http://localhost:8404 > /dev/null 2>&1; then
            echo -e "  ${GREEN}✓${NC} haproxy (running, healthy)"
        else
            echo -e "  ${YELLOW}!${NC} haproxy (running, not responding)"
        fi
    else
        echo -e "  ${RED}✗${NC} haproxy (stopped)"
    fi

    echo ""
    echo "Core services:"
    if curl -s http://localhost:11434/api/tags > /dev/null 2>&1; then
        echo -e "  ${GREEN}✓${NC} ollama (local, healthy)"
    else
        echo -e "  ${RED}✗${NC} ollama (local, not running - run: ollama serve)"
    fi
    if podman ps --format "{{.Names}}" | grep -q "^talkie-chroma$"; then
        if curl -s http://localhost:8000/api/v1/heartbeat > /dev/null 2>&1; then
            echo -e "  ${GREEN}✓${NC} chroma (running, healthy)"
        else
            echo -e "  ${YELLOW}!${NC} chroma (running, not responding)"
        fi
    else
        echo -e "  ${RED}✗${NC} chroma (stopped)"
    fi

    echo ""
    echo "Module servers:"
    for entry in "speech:8001" "rag:8002" "browser:8003"; do
        service="${entry%%:*}"
        port="${entry##*:}"
        if podman ps --format "{{.Names}}" | grep -q "^talkie-$service$"; then
            if curl -s "http://localhost:$port/health" > /dev/null 2>&1; then
                echo -e "  ${GREEN}✓${NC} $service (running, healthy)"
            else
                echo -e "  ${YELLOW}!${NC} $service (running, not responding)"
            fi
        else
            echo -e "  ${RED}✗${NC} $service (stopped)"
        fi
    done
    if podman ps --format "{{.Names}}" | grep -q "^talkie-healthbeat$"; then
        echo -e "  ${GREEN}✓${NC} healthbeat (running)"
    else
        echo -e "  ${RED}✗${NC} healthbeat (stopped)"
    fi

    echo ""
    echo "Service URLs:"
    echo "  Talkie Web UI: http://localhost:8765"
    if [ "$_consul_running" -eq 1 ]; then
        if [ "$_consul_healthy" -eq 1 ]; then
            echo "  Consul UI: http://127.0.0.1:8500/ui"
        else
            echo -e "  Consul UI: http://127.0.0.1:8500/ui ${YELLOW}(container running, API not responding)${NC}"
        fi
    else
        echo -e "  Consul UI: ${YELLOW}(not running)${NC} http://127.0.0.1:8500/ui  -- start: ./talkie start"
    fi
    if podman ps --format "{{.Names}}" | grep -q "^talkie-haproxy$"; then
        echo "  HAProxy Stats: http://localhost:8404"
        echo "  HAProxy: http://localhost:8080"
    else
        echo -e "  HAProxy Stats: ${YELLOW}(not running)${NC} http://localhost:8404  -- start: ./talkie start"
        echo -e "  HAProxy: ${YELLOW}(not running)${NC} http://localhost:8080"
    fi
}

# List containers
cmd_ps() {
    init_compose
    
    log_info "Talkie containers:"
    podman ps --filter "name=talkie-" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
}

# Restart only processes whose code has changed (git diff vs HEAD)
# Maps changed paths to: main app, speech, rag, browser, healthbeat; rebuilds image if needed and restarts only affected containers
cmd_restart_changed() {
    local ref="${1:-HEAD}"
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        log_error "Not a git repository. restart-changed requires git to detect code changes."
        exit 1
    fi
    local changed
    changed=$( { git diff --name-only "$ref"; git diff --name-only --cached "$ref"; } 2>/dev/null | sort -u )
    if [ -z "$changed" ]; then
        log_info "No code changes detected (compared to $ref). Nothing to restart."
        return 0
    fi
    local main_changed=0 speech_changed=0 rag_changed=0 browser_changed=0 healthbeat_changed=0 shared_changed=0
    while IFS= read -r path; do
        [ -z "$path" ] && continue
        case "$path" in
            app/*|run.py|run_web.py|run_module_server.py|config.py|config.yaml|persistence/*|llm/*|curation/*|profile/*|web/*|sdk/*)
                main_changed=1
                ;;
            modules/speech/*)
                speech_changed=1
                ;;
            modules/rag/*)
                rag_changed=1
                ;;
            modules/browser/*)
                browser_changed=1
                ;;
            modules/api/healthbeat*)
                healthbeat_changed=1
                ;;
            modules/api/*|modules/__init__.py|modules/discovery.py)
                shared_changed=1
                ;;
        esac
    done <<< "$changed"
    if [ "$shared_changed" -eq 1 ]; then
        speech_changed=1
        rag_changed=1
        browser_changed=1
        healthbeat_changed=1
    fi
    local any_module=$(( speech_changed + rag_changed + browser_changed + healthbeat_changed ))
    if [ "$any_module" -eq 0 ]; then
        if [ "$main_changed" -eq 1 ]; then
            log_warn "Only main app code changed (app/, run.py, run_web.py, config, etc.). Restart the main app manually (e.g. ./talkie app)."
        fi
        return 0
    fi
    if [ "$main_changed" -eq 1 ]; then
        log_warn "Main app code also changed. Restart the main app manually to pick up those changes."
    fi
    init_compose
    local to_restart=""
    [ "$speech_changed" -eq 1 ] && to_restart="$to_restart speech"
    [ "$rag_changed" -eq 1 ]   && to_restart="$to_restart rag"
    [ "$browser_changed" -eq 1 ] && to_restart="$to_restart browser"
    [ "$healthbeat_changed" -eq 1 ] && to_restart="$to_restart healthbeat"
    to_restart=$(echo "$to_restart" | xargs)
    if [ -z "$to_restart" ]; then
        return 0
    fi
    log_info "Rebuilding module image(s) (code changed)..."
    $COMPOSE_CMD build $to_restart 2>/dev/null || $COMPOSE_CMD build $to_restart
    log_info "Restarting only affected containers: $to_restart"
    $COMPOSE_CMD restart $to_restart
    log_info "Done. Restarted: $to_restart"
}

# Download assets (Vosk + Whisper models, dirs; optional rifai PDFs). Sync, only missing.
VOSK_MODEL_NAME="vosk-model-small-en-us-0.15"
VOSK_URL="https://alphacephei.com/vosk/models/${VOSK_MODEL_NAME}.zip"

cmd_download() {
    local do_rifai="${1:-}"
    log_info "Creating directories: models, downloads, data..."
    mkdir -p models downloads data
    # Vosk: sync, only if missing
    if [ -d "models/${VOSK_MODEL_NAME}" ]; then
        log_info "Vosk model already present: models/${VOSK_MODEL_NAME}"
    else
        log_info "Downloading Vosk model: ${VOSK_MODEL_NAME}..."
        if command -v curl &>/dev/null; then
            curl -sL -o "models/${VOSK_MODEL_NAME}.zip" "$VOSK_URL" || { log_error "Download failed."; exit 1; }
        else
            wget -q -O "models/${VOSK_MODEL_NAME}.zip" "$VOSK_URL" || { log_error "Download failed."; exit 1; }
        fi
        log_info "Extracting to models/${VOSK_MODEL_NAME}..."
        ( cd models && unzip -o -q "${VOSK_MODEL_NAME}.zip" && rm -f "${VOSK_MODEL_NAME}.zip" ) || { log_error "Unzip failed."; exit 1; }
        log_info "Vosk model ready: models/${VOSK_MODEL_NAME}"
    fi
    # Whisper: sync, only if not already cached (faster-whisper uses Hugging Face cache)
    if (stt_engine=$(grep -E "^\s*engine:\s*" config.yaml 2>/dev/null | head -1); echo "$stt_engine" | grep -qi "whisper"); then
        pipenv run python -c '
import sys
from pathlib import Path
root = Path(".").resolve()
if str(root) not in sys.path:
    sys.path.insert(0, str(root))
try:
    from config import load_config
    cfg = load_config()
    stt = cfg.get("stt") or {}
    if (stt.get("engine") or "vosk").lower() != "whisper":
        sys.exit(0)
    whisper_cfg = stt.get("whisper") or {}
    model = (whisper_cfg.get("model_path") or "base").strip() or "base"
    from modules.speech.stt.whisper_engine import ensure_whisper_model_downloaded
    ensure_whisper_model_downloaded(model)
    print("Whisper", model, "ready")
except ImportError as e:
    if "faster_whisper" in str(e):
        sys.exit(2)
    raise
' 2>/dev/null
        local ret=$?
        if [ "$ret" -eq 0 ]; then
            log_info "Whisper model ready (cached or downloaded)"
        elif [ "$ret" -eq 2 ]; then
            log_info "Whisper not installed (faster_whisper); skip. Use STT engine whisper to pre-download."
        else
            log_warn "Whisper model pre-download failed or skipped (check config and pipenv)."
        fi
    fi
    # Ollama: sync pull/update default models (tinyllama, phi, nomic-embed-text) and config's model_name + embedding_model
    if curl -s -f http://localhost:11434/api/tags >/dev/null 2>&1; then
        local ollama_models="tinyllama phi nomic-embed-text"
        local model_name embed_model
        [ -f config.yaml ] && model_name=$(grep -E "^\s*model_name:" config.yaml | head -1 | sed 's/.*model_name:\s*\([^ ]*\).*/\1/' | tr -d '"')
        [ -n "$model_name" ] && ollama_models="$ollama_models $model_name"
        [ -f config.yaml ] && grep -q "embedding_model:" config.yaml && embed_model=$(grep -E "^\s*embedding_model:" config.yaml | head -1 | sed 's/.*embedding_model:\s*\([^ ]*\).*/\1/' | tr -d '"')
        [ -n "$embed_model" ] && ollama_models="$ollama_models $embed_model"
        for m in $(echo "$ollama_models" | tr ' ' '\n' | sort -u); do
            [ -z "$m" ] && continue
            log_info "Pulling/updating Ollama model '$m'..."
            ollama pull "$m" || log_warn "ollama pull $m failed"
        done
    else
        log_info "Ollama not running; skip. Run 'ollama serve' and re-run ./talkie download to pull/update models."
    fi
    if [ "$do_rifai" = "rifai" ] || [ "$do_rifai" = "--rifai" ]; then
        log_info "Running rifai_scholar_downloader (downloads/abdalla_rifai_publications_open_pdfs)..."
        pipenv run python -m rifai_scholar_downloader || log_warn "rifai download failed or skipped."
    else
        log_info "Optional: run ./talkie download rifai to fetch Scholar PDFs to downloads/."
    fi
}

# Clean up
cmd_clean() {
    local what="${1:-containers}"
    init_compose
    
    case "$what" in
        containers)
            log_warn "Stopping and removing all Talkie containers..."
            $COMPOSE_CMD down
            log_info "Containers cleaned up"
            ;;
        volumes)
            log_warn "Removing all Talkie volumes (this will delete data)..."
            read -p "Are you sure? This will delete all data! [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                $COMPOSE_CMD down -v
                log_info "Volumes removed"
            else
                log_info "Cancelled"
            fi
            ;;
        all)
            log_warn "Removing all Talkie containers and volumes (this will delete data)..."
            read -p "Are you sure? This will delete all data! [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                $COMPOSE_CMD down -v
                podman volume prune -f 2>/dev/null || true
                log_info "Everything cleaned up"
            else
                log_info "Cancelled"
            fi
            ;;
        *)
            log_error "Unknown clean option: $what"
            echo "Usage: ./talkie clean [containers|volumes|all]"
            exit 1
            ;;
    esac
}

# Show usage
usage() {
    cat << EOF
Talkie Service Management CLI

Usage: ./talkie <command> [options]

Commands:
  start [target]
        Start services (default: all). Target: all, core, modules, web, or a
        single service (consul-server, keydb, haproxy, chroma, speech, rag,
        browser, healthbeat).
        - all: consul + keydb + haproxy + chroma + modules + Web UI (http://localhost:8765)
        - core: Chroma only (Ollama is local - run: ollama serve)
        - modules: speech, rag, browser, healthbeat
        - web: Web UI only (run_web.py, port 8765)

  stop [target]
        Stop services (default: all). Same targets as start.

  restart [target]
        Restart services (default: all). Same targets as start.
        - restart changed [REF]: Restart/rebuild only services whose code changed (git diff vs REF, default HEAD).

  status [web]
        Show status and health. No argument: all services + health checks. With web: Web UI only.

  app [--local-only]
        Bring up container services then run the Web UI (foreground).
        - app: Web UI at http://localhost:8765
        - app --local-only: Skip module containers; app may start them as subprocesses

  ps      List running containers

  logs <service> [--follow]
        View logs for a service
        Use --follow or -f to follow logs
        Example: ./talkie logs consul-server --follow

  download [rifai]
        Fetch assets not in git (sync, only missing). Creates models/, downloads/, data/.
        - download: Vosk + Whisper (if config uses whisper) + Ollama models (tinyllama, phi, config model_name/embedding_model)
        - download rifai: also run rifai_scholar_downloader (PDFs to downloads/)

  clean [containers|volumes|all]
        Clean up resources
        - containers: Stop and remove containers
        - volumes: Remove volumes (deletes data)
        - all: Remove everything

  help    Show this help message

Examples:
  ./talkie start                    # Start all services + Web UI (http://localhost:8765)
  ./talkie start web                 # Start Web UI only
  ./talkie restart haproxy           # Restart HAProxy only
  ./talkie restart web               # Restart Web UI only
  ./talkie stop web                  # Stop Web UI
  ./talkie status                    # Status and health of all services
  ./talkie status web                # Web UI only
  ./talkie app                      # Start services + Web UI (foreground)
  ./talkie app --local-only         # Start Web UI only (no module containers)
  ./talkie logs consul-server -f   # Follow Consul logs
  ./talkie download                  # Vosk + Whisper + Ollama (tinyllama, phi, config)
  ./talkie download rifai            # + Scholar PDFs to downloads/
  ./talkie restart changed          # Restart/rebuild only containers whose code changed
  ./talkie clean containers         # Clean up containers

EOF
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        start)
            cmd_start "${1:-all}"
            ;;
        stop)
            cmd_stop "${1:-all}"
            ;;
        restart)
            if [ "${1:-}" = "changed" ]; then
                shift
                cmd_restart_changed "${1:-HEAD}"
            else
                cmd_restart "${1:-all}"
            fi
            ;;
        app)
            cmd_app "$@"
            ;;
        logs)
            cmd_logs "$1" "$2"
            ;;
        status)
            if [ "${1:-}" = "web" ]; then
                cmd_web_status
            else
                cmd_status
            fi
            ;;
        ps)
            cmd_ps
            ;;
        download)
            cmd_download "$1"
            ;;
        clean)
            cmd_clean "${1:-containers}"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
